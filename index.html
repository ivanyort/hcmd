<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Header Change Mask Decoder</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: "Segoe UI", Tahoma, sans-serif;
        margin: 24px;
        line-height: 1.4;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(240px, 320px) 1fr;
        gap: 24px;
        align-items: start;
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: flex-end;
      }
      .panel {
        border: 1px solid #ddd;
        background: #fafafa;
        padding: 16px;
      }
      .repo a {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: inherit;
        text-decoration: none;
        word-break: break-all;
      }
      .repo a:hover {
        text-decoration: underline;
      }
      .repo svg {
        width: 16px;
        height: 16px;
        flex: 0 0 16px;
      }
      .stack {
        display: grid;
        gap: 12px;
      }
      label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
        margin-bottom: 6px;
      }
      .tip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        font-size: 11px;
        line-height: 1;
        cursor: help;
        user-select: none;
      }
      input,
      select,
      button {
        font-size: 14px;
        padding: 8px 10px;
      }
      button {
        cursor: pointer;
      }
      pre {
        background: #f6f6f6;
        padding: 12px;
        white-space: pre-wrap;
        border: 1px solid #ddd;
        margin-top: 16px;
      }
      @media (max-width: 720px) {
        .layout {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <h1>Header Change Mask Decoder</h1>

    <div class="layout">
      <div class="panel stack">
        <div>
          <label for="language">
            <span data-i18n="labelLanguage">Language</span>
            <span class="tip" data-i18n-title="tipLanguage">?</span>
          </label>
          <select id="language">
            <option value="pt">pt-BR</option>
            <option value="en">en-US</option>
            <option value="es">es-ES</option>
          </select>
        </div>
        <div>
          <label for="eventhubs">
            <span data-i18n="labelEventHubs">Streaming target</span>
            <span class="tip" data-i18n-title="tipEventHubs">?</span>
          </label>
          <select id="eventhubs">
            <option value="n" selected data-i18n="optionNo">no</option>
            <option value="y" data-i18n="optionYes">yes</option>
          </select>
        </div>
        <div>
          <label for="discard-bits">
            <span data-i18n="labelDiscardBits">Bits to discard</span>
            <span class="tip" data-i18n-title="tipDiscardBits">?</span>
          </label>
          <input
            id="discard-bits"
            type="number"
            min="0"
            step="1"
            value="7"
            data-i18n-placeholder="placeholderDiscardBits"
          />
        </div>
        <div>
          <label for="hex">
            <span data-i18n="labelHex">header__change_mask (hexadecimal)</span>
            <span class="tip" data-i18n-title="tipHex">?</span>
          </label>
          <input id="hex" type="text" placeholder="0x..." data-i18n-placeholder="placeholderHex" />
        </div>
        <div>
          <button id="decode" data-i18n="buttonDecode">Decode</button>
        </div>
        <div>
          <small>
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" width="16" height="16">
              <path
                fill="currentColor"
                d="M12 12c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm0 2c-3.33 0-10 1.67-10 5v3h20v-3c0-3.33-6.67-5-10-5z"
              ></path>
            </svg>
            Ivan Yort &lt;ivan.yort@qlik.com&gt;
          </small>
        </div>
        <div class="repo">
          <small>
            <a href="https://github.com/ivanyort/hcmd" target="_blank" rel="noopener">
              <svg viewBox="0 0 16 16" aria-hidden="true" focusable="false">
                <path
                  fill="currentColor"
                  d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38
                  0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13
                  -.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66
                  .07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15
                  -.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68
                  0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51
                  .56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48
                  0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8 8 0 0 0 16 8c0-4.42-3.58-8-8-8z"
                ></path>
              </svg>
              <span>https://github.com/ivanyort/hcmd</span>
            </a>
          </small>
        </div>
        <div class="repo">
          <small>
            <a href="https://ivanyort.github.io/hcmd/" target="_blank" rel="noopener">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  fill="currentColor"
                  d="M10.59 13.41a1.996 1.996 0 0 0 2.82 0l3.18-3.18a2 2 0 1 0-2.82-2.82l-1.06 1.06a1 1 0 1 1-1.42-1.42l1.06-1.06a4 4 0 1 1 5.66 5.66l-3.18 3.18a4 4 0 0 1-5.66 0 1 1 0 0 1 1.42-1.42zM13.41 10.59a1.996 1.996 0 0 0-2.82 0l-3.18 3.18a2 2 0 1 0 2.82 2.82l1.06-1.06a1 1 0 1 1 1.42 1.42l-1.06 1.06a4 4 0 1 1-5.66-5.66l3.18-3.18a4 4 0 0 1 5.66 0 1 1 0 0 1-1.42 1.42z"
                ></path>
              </svg>
              <span>https://ivanyort.github.io/hcmd</span>
            </a>
          </small>
        </div>
      </div>

      <div class="panel">
        <pre id="output" aria-live="polite"></pre>
        <pre id="steps" aria-live="polite"></pre>
      </div>
    </div>

    <script>
      const STORAGE_KEY = "headerChangeMaskDecoderState";
      const TRANSLATIONS = {
        en: {
          labelLanguage: "Language",
          labelEventHubs: "Is the target Event Hubs?",
          labelDiscardBits: "Bits to discard",
          labelHex: "header__change_mask",
          placeholderHex: "0x...",
          placeholderDiscardBits: "7",
          tipLanguage: "Choose the UI language.",
          tipEventHubs: "Select yes when the target technology is Event Hubs.",
          tipDiscardBits:
            "How many rightmost bits should be discarded. Equivalent to the number of \"header__\" fields stored in the __ct table. Default is 7 fields, but this can change due to specific configurations. This value becomes 0 when the target is Event Hubs.",
          tipHex: "Hex value for header__change_mask (prefix 0x optional).",
          buttonDecode: "Decode",
          msgHexRequired: "Enter a hexadecimal value.",
          msgHexInvalid: "Invalid hexadecimal.",
          stepTitle: "Step by step",
          stepInput: "1) Input",
          stepTarget: "Is the target Event Hubs?",
          stepDiscardBits: "Bits to discard",
          stepOriginal: "Original value",
          stepNormalized: "Normalized value",
          stepHexToBin: "2) Hex to binary (8 bits per byte)",
          stepHexLabel: "hex",
          stepBinLabel: "bin",
          stepBits: "3) Bits considered",
          stepTargetN: "Event Hubs target = no, discarding the last",
          stepBitsSuffix: "bits",
          stepTargetY: "Event Hubs target = yes, no bit discard",
          stepFullBits: "Full bits (right-aligned)",
          stepBitsUsed: "Bits used (aligned)",
          stepDiscarded: "Discarded bits",
          stepLeadingZeros: "4) Leading zeros removal",
          stepBeforeTrim: "Before trim",
          stepAfterTrim: "After trim",
          stepTrimNote:
            "After trimming leading zeros, the rightmost bit becomes the 1st field",
          stepMapping: "5) Column mapping",
          stepMappingDesc: "Each bit from right to left maps to a column.",
          stepMappingLegend: "1 = UPDATED, 0 = unmodified.",
          outHeader: "header__change_mask = 0x",
          outBinaryView: "Binary View",
          outFirstColumn: "First column = 1 (not zero)",
          outUpdated: "UPDATED",
          outUnmodified: "unmodified",
          outColumn: "column",
          outColumnGe: "column greater or equal than",
          outField: "field",
          outFieldEqual: "=",
          outFieldUnmodified: "unmodified",
          outFieldUpdated: "UPDATED",
          outNthField: "n o campo (=)",
          outEllipsis: "...",
          optionNo: "no",
          optionYes: "yes",
        },
        pt: {
          labelLanguage: "Idioma",
          labelEventHubs: "Destino é Event Hubs?",
          labelDiscardBits: "Bits a descartar",
          labelHex: "header__change_mask",
          placeholderHex: "0x...",
          placeholderDiscardBits: "7",
          tipLanguage: "Escolha o idioma da interface.",
          tipEventHubs: "Selecione sim caso a tecnologia de destino seja Event Hubs.",
          tipDiscardBits:
            "Quantos bits finais devem ser descartados. Equivalente a quantidade de campos \"header__\" que estão sendo armazenados na tabela __ct. Por padrão são 7 campos, mas esse número pode mudar devido a configurações específicas. Esse valor se torna 0 caso o destino seja Event Hubs.",
          tipHex: "Valor hex do header__change_mask (prefixo 0x opcional).",
          buttonDecode: "Decodificar",
          msgHexRequired: "Informe um valor hexadecimal.",
          msgHexInvalid: "Hexadecimal inválido.",
          stepTitle: "Passo a passo",
          stepInput: "1) Entrada",
          stepTarget: "Destino é Event Hubs?",
          stepDiscardBits: "Bits a descartar",
          stepOriginal: "Valor informado",
          stepNormalized: "Valor normalizado",
          stepHexToBin: "2) Conversão hexadecimal -> binário (8 bits por byte)",
          stepHexLabel: "hex",
          stepBinLabel: "bin",
          stepBits: "3) Bits considerados",
          stepTargetN: "Destino Event Hubs = não, descartando os",
          stepBitsSuffix: "bits finais",
          stepTargetY: "Destino Event Hubs = sim, sem descarte de bits",
          stepFullBits: "Bits completos",
          stepBitsUsed: "Bits usados",
          stepDiscarded: "Bits descartados",
          stepLeadingZeros: "4) Remoção de zeros à esquerda",
          stepBeforeTrim: "Antes do trim",
          stepAfterTrim: "Depois do trim",
          stepTrimNote:
            "Após remover zeros iniciais, o bit mais à direita vira o 1º campo",
          stepMapping: "5) Mapeamento de colunas",
          stepMappingDesc: "Cada bit da direita para a esquerda mapeia uma coluna.",
          stepMappingLegend: "1 = ATUALIZADO, 0 = não modificado.",
          outHeader: "header__change_mask = 0x",
          outBinaryView: "Vista binária",
          outFirstColumn: "Primeira coluna = 1 (não zero)",
          outUpdated: "ATUALIZADO",
          outUnmodified: "não modificado",
          outColumn: "coluna",
          outColumnGe: "coluna maior ou igual a",
          outField: "campo",
          outFieldEqual: "=",
          outFieldUnmodified: "não modificado",
          outFieldUpdated: "ATUALIZADO",
          outNthField: "nº campo (=)",
          outEllipsis: "...",
          optionNo: "não",
          optionYes: "sim",
        },
        es: {
          labelLanguage: "Idioma",
          labelEventHubs: "El destino es Event Hubs?",
          labelDiscardBits: "Bits a descartar",
          labelHex: "header__change_mask",
          placeholderHex: "0x...",
          placeholderDiscardBits: "7",
          tipLanguage: "Elija el idioma de la interfaz.",
          tipEventHubs: "Seleccione si cuando la tecnologia de destino sea Event Hubs.",
          tipDiscardBits:
            "Cuantos bits finales deben descartarse. Equivalente al numero de campos \"header__\" que se almacenan en la tabla __ct. Por defecto son 7 campos, pero este numero puede cambiar por configuraciones especificas. Este valor se vuelve 0 cuando el destino es Event Hubs.",
          tipHex: "Valor hex de header__change_mask (prefijo 0x opcional).",
          buttonDecode: "Decodificar",
          msgHexRequired: "Ingrese un valor hexadecimal.",
          msgHexInvalid: "Hexadecimal inválido.",
          stepTitle: "Paso a paso",
          stepInput: "1) Entrada",
          stepTarget: "El destino es Event Hubs?",
          stepDiscardBits: "Bits a descartar",
          stepOriginal: "Valor ingresado",
          stepNormalized: "Valor normalizado",
          stepHexToBin: "2) Hexadecimal a binario (8 bits por byte)",
          stepHexLabel: "hex",
          stepBinLabel: "bin",
          stepBits: "3) Bits considerados",
          stepTargetN: "Destino Event Hubs = no, descartando los ultimos",
          stepBitsSuffix: "bits",
          stepTargetY: "Destino Event Hubs = sí, sin descarte de bits",
          stepFullBits: "Bits completos",
          stepBitsUsed: "Bits usados",
          stepDiscarded: "Bits descartados",
          stepLeadingZeros: "4) Eliminación de ceros a la izquierda",
          stepBeforeTrim: "Antes del trim",
          stepAfterTrim: "Después del trim",
          stepTrimNote:
            "Tras eliminar ceros iniciales, el bit más a la derecha se vuelve el 1.er campo",
          stepMapping: "5) Mapeo de columnas",
          stepMappingDesc: "Cada bit de derecha a izquierda mapea una columna.",
          stepMappingLegend: "1 = ACTUALIZADO, 0 = no modificado.",
          outHeader: "header__change_mask = 0x",
          outBinaryView: "Vista binaria",
          outFirstColumn: "Primera columna = 1 (no cero)",
          outUpdated: "ACTUALIZADO",
          outUnmodified: "no modificado",
          outColumn: "columna",
          outColumnGe: "columna mayor o igual que",
          outField: "campo",
          outFieldEqual: "=",
          outFieldUnmodified: "no modificado",
          outFieldUpdated: "ACTUALIZADO",
          outNthField: "n o campo (=)",
          outEllipsis: "...",
          optionNo: "no",
          optionYes: "sí",
        },
      };

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch (err) {
          return null;
        }
      }

      function saveState() {
        const state = {
          language: document.getElementById("language").value,
          eventhubs: document.getElementById("eventhubs").value,
          discardBits: document.getElementById("discard-bits").value,
          hex: document.getElementById("hex").value,
        };
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (err) {
          // Ignore storage errors (quota, privacy mode).
        }
      }

      function applyLanguage(lang) {
        const t = TRANSLATIONS[lang] || TRANSLATIONS.pt;
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.getAttribute("data-i18n");
          if (t[key]) {
            el.textContent = t[key];
          }
        });
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.getAttribute("data-i18n-placeholder");
          if (t[key]) {
            el.setAttribute("placeholder", t[key]);
          }
        });
        document.querySelectorAll("[data-i18n-title]").forEach((el) => {
          const key = el.getAttribute("data-i18n-title");
          if (t[key]) {
            el.setAttribute("title", t[key]);
            el.setAttribute("aria-label", t[key]);
          }
        });
      }

      function ordinalLabel(value, lang) {
        if (lang === "pt" || lang === "es") {
          return `${value}º`;
        }
        const mod100 = value % 100;
        if (mod100 >= 11 && mod100 <= 13) {
          return `${value}th`;
        }
        const mod10 = value % 10;
        if (mod10 === 1) return `${value}st`;
        if (mod10 === 2) return `${value}nd`;
        if (mod10 === 3) return `${value}rd`;
        return `${value}th`;
      }

      function decodeHeaderChangeMask() {
        const lang = document.getElementById("language").value;
        const t = TRANSLATIONS[lang] || TRANSLATIONS.pt;
        const eventhubs = document
          .getElementById("eventhubs")
          .value.trim()
          .toLowerCase();
        const discardInput = document.getElementById("discard-bits").value.trim();
        const discardBits = Math.max(
          0,
          Number.parseInt(discardInput || "7", 10) || 7
        );
        let hexString = document.getElementById("hex").value.trim().toLowerCase();
        const output = document.getElementById("output");
        const steps = document.getElementById("steps");
        steps.textContent = "";

        if (!hexString) {
          output.textContent = t.msgHexRequired;
          return;
        }

        const originalInput = hexString;
        if (hexString.startsWith("0x")) {
          hexString = hexString.substring(2);
        }

        while (hexString.length % 2 !== 0) {
          hexString = "0" + hexString;
        }

        let hexToBin = "";
        let ruler1 = "";
        let ruler2 = "";

        let c = eventhubs === "y" ? 0 : -discardBits;

        for (let i = 0; i < hexString.length; i += 2) {
          const bte = hexString.substring(i, i + 2);
          const parseIntValue = Number.parseInt(bte, 16);
          if (Number.isNaN(parseIntValue)) {
            output.textContent = t.msgHexInvalid;
            return;
          }
          let bin = parseIntValue.toString(2);
          while (bin.length < 8) {
            bin = "0" + bin;
          }
          hexToBin = hexToBin + " " + bin;
          for (let k = 0; k < 8; k++) {
            let p = String(c + 1);
            if (c < 0) {
              p = "-";
            } else {
              p = p.substring(p.length - 1);
            }
            if ((c + 1) % 10 === 0 && c + 1 !== 0) {
              const z = "0" + String(c + 1);
              ruler1 = z.substring(z.length - 2, z.length - 1) + ruler1;
            } else {
              ruler1 = "." + ruler1;
            }

            ruler2 = p + ruler2;
            c++;
          }
          ruler1 = " " + ruler1;
          ruler2 = " " + ruler2;
        }

        hexToBin = hexToBin.trim();
        ruler1 = ruler1.trim();
        ruler2 = ruler2.trim();

        let out = "";
        out += "\n";
        out += t.outHeader + hexString + "\n\n";
        out += t.outBinaryView + "\n";
        out += ruler1 + "\n";
        out += ruler2 + "\n";
        out += hexToBin + "\n\n";
        out += t.outFirstColumn + "\n";

        let bits = hexToBin.replace(/\s+/g, "");
        const originalBits = bits;
        const effectiveDiscard = eventhubs === "y" ? 0 : discardBits;
        if (effectiveDiscard > 0) {
          bits = bits.substring(0, Math.max(0, bits.length - effectiveDiscard));
        }
        const bitsBeforeTrim = bits;

        while (bits.length > 0 && bits.startsWith("0")) {
          bits = bits.substring(1);
        }

        c = 0;
        for (let b = bits.length - 1; b >= 0; b--) {
          if (bits.substring(b, b + 1) === "1") {
            out += `${t.outColumn} ${String(++c).padStart(3, "0")} = ${t.outUpdated}\n`;
          } else {
            out += `${t.outColumn} ${String(++c).padStart(3, "0")} = ${t.outUnmodified}\n`;
          }
        }
        out += `${t.outColumnGe} ${String(bits.length + 1).padStart(
          3,
          "0"
        )} = ${t.outUnmodified}\n`;

        output.textContent = out;

        let stepText = "";
        stepText += `${t.stepTitle}\n`;
        stepText += `${t.stepInput}\n`;
        const step1Labels = [
          t.stepTarget,
          t.stepDiscardBits,
          t.stepOriginal,
          t.stepNormalized,
        ];
        const step1Max = step1Labels.reduce(
          (max, label) => Math.max(max, label.length),
          0
        );
        const padStep1 = (label) => label + " ".repeat(step1Max - label.length);
        stepText += `   ${padStep1(t.stepTarget)} = ${eventhubs}\n`;
        stepText += `   ${padStep1(t.stepDiscardBits)} = ${discardBits}\n`;
        stepText += `   ${padStep1(t.stepOriginal)} = ${originalInput}\n`;
        stepText += `   ${padStep1(t.stepNormalized)} = 0x${hexString}\n`;
        stepText += `${t.stepHexToBin}\n`;
        stepText += `   ${t.stepHexLabel} = 0x${hexString}\n`;
        stepText += `   ${t.stepBinLabel} = ${hexToBin}\n`;
        stepText += `${t.stepBits}\n`;
        const step3Labels = [t.stepFullBits, t.stepBitsUsed, t.stepDiscarded];
        const step3Max = step3Labels.reduce(
          (max, label) => Math.max(max, label.length),
          0
        );
        const padLabel = (label) => label + " ".repeat(step3Max - label.length);
        if (eventhubs !== "y") {
          const width = originalBits.length;
          const discardCount = Math.min(effectiveDiscard, width);
          const usedSection = originalBits.slice(0, width - discardCount);
          const discardedSection = originalBits.slice(width - discardCount);
          const usedAligned = `${usedSection}${".".repeat(discardCount)}`;
          const discardedAligned = `${".".repeat(width - discardCount)}${discardedSection}`;
          stepText += `   ${t.stepTargetN} ${discardBits} ${t.stepBitsSuffix}\n`;
          stepText += `   ${padLabel(t.stepFullBits)} = ${originalBits}\n`;
          stepText += `   ${padLabel(t.stepBitsUsed)} = ${usedAligned}\n`;
          if (discardCount > 0) {
            stepText += `   ${padLabel(t.stepDiscarded)} = ${discardedAligned}\n`;
          }
        } else {
          stepText += `   ${t.stepTargetY}\n`;
          stepText += `   ${padLabel(t.stepFullBits)} = ${originalBits}\n`;
          stepText += `   ${padLabel(t.stepBitsUsed)} = ${originalBits}\n`;
        }
        stepText += `${t.stepLeadingZeros}\n`;
        const step4Labels = [t.stepBeforeTrim, t.stepAfterTrim];
        const step4Max = step4Labels.reduce(
          (max, label) => Math.max(max, label.length),
          0
        );
        const padStep4 = (label) => label + " ".repeat(step4Max - label.length);
        stepText += `   ${padStep4(t.stepBeforeTrim)} = ${bitsBeforeTrim}\n`;
        stepText += `   ${padStep4(t.stepAfterTrim)} = ${bits}\n`;
        stepText += `   ${t.stepTrimNote}\n`;
        stepText += `${t.stepMapping}\n`;
        stepText += `   ${t.stepMappingDesc}\n`;
        stepText += `   ${t.stepMappingLegend}\n`;

        const afterTrimLabel = `   ${padStep4(t.stepAfterTrim)} = `;
        stepText += `${afterTrimLabel}${bits}\n`;
        if (bits.length > 0) {
          stepText += `${" ".repeat(afterTrimLabel.length)}${"│".repeat(
            bits.length
          )}\n`;
        }

        const targetArrowEnd = afterTrimLabel.length + bits.length + 6;
        const labelStart = targetArrowEnd + 2;
        for (let i = 0; i < bits.length; i++) {
          const field = i + 1;
          const bit = bits.substring(bits.length - 1 - i, bits.length - i);
          const status = bit === "1" ? t.outFieldUpdated : t.outFieldEqual;
          const columnIndex = bits.length - field;
          const leftPad = " ".repeat(afterTrimLabel.length);
          const verticals = "│".repeat(columnIndex);
          const currentStart = afterTrimLabel.length + columnIndex + 1;
          const horizLen = Math.max(1, labelStart - (currentStart + 2));
          const arrow = `└${"─".repeat(horizLen)}>`;
          stepText += `${leftPad}${verticals}${arrow} ${ordinalLabel(
            field,
            lang
          )} ${t.outField} (${status})\n`;
        }

        if (bits.length > 0) {
          const labelPad = " ".repeat(labelStart);
          stepText += `${labelPad}${ordinalLabel(
            bits.length + 1,
            lang
          )} ${t.outField} (=)\n`;
          stepText += `${labelPad}${t.outEllipsis}\n`;
          stepText += `${labelPad}${t.outNthField}\n`;
        }

        steps.textContent = stepText;
      }

      const saved = loadState();
      const savedLang = saved && saved.language ? saved.language : "pt";
      document.getElementById("language").value = savedLang;
      if (saved) {
        if (saved.eventhubs) {
          document.getElementById("eventhubs").value = saved.eventhubs;
        }
        if (saved.discardBits !== undefined && saved.discardBits !== null) {
          document.getElementById("discard-bits").value = saved.discardBits;
        }
        if (saved.hex) {
          document.getElementById("hex").value = saved.hex;
        }
      }
      applyLanguage(savedLang);

      document.getElementById("decode").addEventListener("click", decodeHeaderChangeMask);
      document.getElementById("hex").addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          decodeHeaderChangeMask();
        }
      });
      document.getElementById("eventhubs").addEventListener("change", saveState);
      document.getElementById("discard-bits").addEventListener("input", saveState);
      document.getElementById("hex").addEventListener("input", saveState);
      document.getElementById("language").addEventListener("change", (event) => {
        applyLanguage(event.target.value);
        saveState();
      });
    </script>
  </body>
</html>
